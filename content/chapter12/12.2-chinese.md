#12.2 如何使用WebCL编程

WebCL 1.0其实就是使用JavaScript实现的OpenCL 1.2。这就意味着调用同样的OpenCL API、语法以及运行时，无需太多行代码就能完成(JavaScript是面向对象的语言)。我们通常会将WebCL与其他类似的技术联系在一起进行比较。如果你对WebGL很不了解，对于讨论WebCL也是没有关系的。

与OpenCL一样，WebCL的编程也是由两部分构成：

1. 主机端(例如，Web浏览器)用来控制和执行JavaScript程序
2. 设备端(例如，GPU)用来进行计算——OpenCL内核

和WebGL一样，WebCL也属于窗口对象的特性。首先，我们要检查WebCL是否可用，如果可用，则创建对应的上下文对象：

```c++
// First check if the WebCL extension is installed at all
if (window.webcl == undefined){
  alert("Unfortunately your system does not support WebCL." +
  "Make sure that you have both the OpenCL dirver" +
  "and the WebCL browser extension installed.");
}

// Get a list of available CL platforms, and another list of the
// available devices on each platform. If there are no platforms
// or no available devices on any platform, then we can conclude
// that WebCL is not available
webcl = window.webcl
try{
  var platforms = webcl.getPlatforms();
  var devices = [];
  for (var i in platforms){
    var p = platforms[i];
    devices[i] = p.getDevices();
  }
  
  alert("Excellent! Your system does support WebCL");
} catch(e){
  alert("Unfortunately platform or device inquiry failed.");
}

// Setup WebCL context using the default device
var ctx = webcl.createContext();
```

![](../../images/chapter12/12-1.png)

图12.1 WebCL对象


图12.1中描述了WebCL中的对象结构关系。注意WebCL是接口的名字，而webcl是JavaScript的对象。更多信息可以查阅WebCL的标准[1]。

Web应用无法获取平台信息之后，列出所有可以用的设备；而是通过获取到的设备信息了解对应平台，从而指定对应的设备或平台。

```c++
// Find appropriate device
for (var j = 0, jl = device.length; j < jl; ++j){
  var d = devices[j];
  var devExts = d.getInfo(cl.DEVICE_EXTENSIONS);
  var devGMem = d.getInfo(cl.DEVICE_GLOBAL_MEM_SIZE);
  var devLMem = d.getInfo(cl.DEVICE_LOCAL_MEM_SIZE);
  var devCompUnits = d.getInfo(cl.DEVICE_MAX_COMPUTE_UNITS);
  var devHasImage = d.getInfo(cl.DEVICE_IMAGE_SUPPORT);
  
// select device that matches your requirements
  platform = ...
  device = ...
}

// assuming we found the best device, we can create the context
var context = webcl.createContext(platform, device);
```

应用会在运行时对OpenCL对象进行管理，比如：命令队列、内存对象、程序对象、内核对象，以及入队命令(比如：执行内核、读取内存对象或写入内存对象)。

WebCL中定义了如下对象：

- **命令队列**
- 内存对象(**数组**和**图像**)
- **采样器**对象，其描述了在内核中如何对图像进行读取
- **程序**对象，其包含了一些列内核函数
- **内核**对象，在内核源码中使用__kernel声明的函数，其作为真正的执行对象
- **事件**对象，其用来追踪命令执行状态，以及对一个命令进行性能分析
- 命令同步对象，比如**标记**和**栅栏**

首先我们需要创建程序对象。WebCL与WebGL 1.0类似，假设可以提供一段内核源码。这样的话，Web应用就需要内嵌一个编译器。源码先从设备上进行载入，之后进行编译。和其他编译器一样，OpenCL编译器也定义了一些编译选项。

```c++
// Create the compute program from the source strings
program = context.createProgram(source);

// Build the program executable with relaxed math flag
try{
  program.build(device, "-cl-fast-relaxed-math");
} catch(err) {
  throw 'Error building program:' + err + program.getBuildInfo(device, cl.PROGRAM_BUILD_LOG);
}
```

如此这般，我们的程序就可以编译了，并且一个程序对象内具有一个或者多个内核函数。这些内核函数作为我们程序的入口函数，就如同静态库中的接口一样。为了区别不同的内核函数，我们需要创建WebCLKernel对象：

```c++
// Create the compute kernels from within the program
var kernel = program.createKernel("kernel_function_name");
```

就像普通函数一样，内核函数通常都会有一些参数。JavaScript会提供一些数据类型，typed arrays[2]就是用来传递不同类型的内核参数(具体参数类型见表12.1)。对于其他类型的数据，我们可以使用WebCL对象：

- WebCLBuffer和WebCLImage，可以用来包装数组
- WebCLSampler可以对图像进行采样

一个WebCLBuffer对象可以将数据以一维的方式存储起来。数组中错存储的元素类型都可以使标量类型(比如：int或float)，向量类型，或是自定义结构体类型。

表12.1 在setArg()中使用的webcl.type与C类型之间的关系

内核参数类型|setArg()值的类型|setArg()数组类型|注意
----|----|----|----
char, uchar|scalar|Uint8Array, Int8Arrary|1 byte
short, ushort|scalar|Uint16Array, Int16Array|2 bytes
int, uint| scalar|Uint32Array, Int32Array|4 bytes
long, ulong |scalar|Uint64Array, Int64Array|8 bytes
float | scalar|Float32Array|4 bytes
charN|vector|Int8Array for (u)charN|N = 2,3,4,8,16
shortN|vector|Int16Array for (u)shortN|N = 2,3,4,8,16
intN|vector|Int32Array for (u)intN|N = 2,3,4,8,16
floatN|vector|Float32Array for floatN and halfN|N = 2,3,4,8,16
doubleN|vector|Float64Array for (u)doubleN|N = 2,3,4,8,16
char, ..., double *|WebCLBuffer||
image2d_t| WebCLImage||
sampler_t|WebCLSampler||
__local||Int32Array([size_in_bytes])|内核内部定义大小

```c++
// Create a 1D buffer
var buffer = webcl.createBuffer(flags, sizeInBytes, optional srcBuffer);

// flags:
// webcl.MEM_READ_WRITE Default. Memory object is read and written by kernel
// webcl.MEM_WRITE_ONLY Memory object only writeten by kernel
// webcl.MEM_READ_ONLY Memory object only read by kernel
// webcl.MEM_USE_HOST_PTR Implementation requests OpenCL to allocate host memory
// webcl.MEM_COPY_HOST_PTR Implementation requests OpenCL to allocate host memory and copy data from srcBuffer memory. srcBuffer must be specified
```

注意，只有从内存对象或其子对象中读取数据，或读取多个具有重叠区域的子内存对象是有定义的。其他方式的并发读写都会产生未定义的行为。

WebCL图像对象可以存储1,2,3维的纹理，渲染内存或图像。图像对象中的元素可以从预定义的图像格式列表中选择。当前的WebCL版本最多只支持到二维图像。

```c++
// create a 32-bit RGBA WebCLImage object
// first, we define the format of the image
var imageFormat = {
  // memory layout in which pixel data channels are stored in the image
  'channelOrder':webcl.RGBA,
  // type of the channel data
  'channelType':webcl.UNSIGNED_INT8,
  // image size
  'width':image_width,
  'height':image_height,
  // scan-line pitch in bytes.
  // If imageBuffer is null, which is the default if rowPitch is not specified.
  'rowPitch'：image_pitch
};

// Image on device
// imageBuffer is a typed array that contain the image data already allocated by the application
// imageBuffer.byteLength >= rowPitch * image_height. The size of each element in bytes must be a power of 2.

var image = context.createImage(webcl.MEM_READ_ONLY | webcl.MEM_USE_HOST_PTR, imageFormat, imageBuffer);
```

WebCLSampler告诉内核函数读和对图像数据进行读取。WebCL的采样器和WebGL的采样器类似。

```c++
// create a smpler object
var sampler = context.createSampler(normalizedCoords, addressingMode, filterMode);
// normalizedCoods indicates if image coordinates specified are normalized.
// addressingMode indicated how out-of-range image coordinations are handled when reading an image.
// This can be set to webcl.ADDRESS_MIRRORED_REPEAT
// webcl.ADDRESS_REPEAT, webcl.ADDRESS_CLAMP_TO_EDGE,
// webcl.ADDRESS_CLAMP and webcl.ADDRESS_NONE.
// filterMode specifies the type of filter to apply when reading an image. This can be webcl.FILTER_NEAREST or webcl.FILTER_LINEAR
```

使用WebCLKernel.setArg()将标量、向量或内存对象以参数的形式传入内核。需要传递局部内存时，我们可以使用长度为1的Int32Array，其中的数值是需要分配多少字节的局部内存，因为局部内存不能在主机端或设备端初始化，不过主机端可以通过内核参数的形式告诉设备端要分配多少局部内存。

![](../../images/chapter12/12-2.png)

-----------

[1] WebCL 1.0 Specification, http://www.khronos.org/registry/webcl/specs/latest/1.0
