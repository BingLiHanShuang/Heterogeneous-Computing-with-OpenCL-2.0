#3.2 OpenCL平台模型

OpenCL平台需要包含一个主处理器和一个或多个OpenCL设备。平台模型定义了host和device的角色，并且为device提供了一种抽象的硬件模型。一个device可以被划分成一个或多个计算单元，这些计算单元在之后能被分成一个或多个“处理单元”(*processing elements*)。具体的关系可见图3.1。

![](../../images/chapter3/3-1.png)

图3.1 OpenCL平台具有多个计算设备。每个计算设备都具有一个或多个计算单元。一个计算单元又由一个或多个处理元素(PEs)构成。系统中可以同时具有多个平台。例如，在一个系统中可以既有AMD的平台和Intel的平台。

平台模型是应用开发的重点，其保证了OpenCL代码的可移植性(在具有OpenCL能力的系统间)。即使只在一个系统中，这个系统也可以具有多个不同的OpenCL平台，这些平台可以被不同的应用所使用。平台模型的API允许一个OpenCL应用能够适应和选择对应的平台和计算设备，从而在相应平台和设备上运行应用。

应用可以使用OpenCL运行时API层面，选择对应提供商提供的对应平台。不过，平台上能指定和互动的设备，也只限于供应商提供的哪些设备。例如，如果选择了A公司的平台，那么就不能使用B公司的GPU。不过，平台硬件并不需要由供应商独家提供。例如，AMD和Intel的实现可以使用其他公司的x86 CPU作为设备。

编程者写编写OpenCL C代码时，设备架构会被抽象成平台模型。供应商只需要将抽象的架构映射到对应的物理硬件上即可。平台模型定义了具有一组计算单元的设备，且每个计算单元的功能都是独立的。计算单元也可以划分陈更多个处理单元。图3.1展示的就是这样的一种层级模型。举个例子，AMD Radeon R9 290X图形卡(device)包含44个向量处理器(计算单元)。每个计算单元都由4个16通道SIMD引擎，一共就有64个SIMD通道(处理单元)。Radeon R9 290X上每个SIMD通道都能处理一个标量指令。这就运行GPU设备能同时执行44x16x4=2816条指令。

##3.2.1 平台和设备

`clGetPlatformIDs()`这个API就是查找制定系统上的可用OpenCL平台的集合。在具体的OpenCL程序中，这个API一般会调用两次，用来查询和获取到对应的平台信息。第一次调用这个API需要传入`num_platforms`作为数量参数，传入NULL作为平台参数。这样就能获取在该系统上有多少个平台可供使用。编程者可以开辟对应大小的空间(指针命名为platforms)，来存放对应的平台对象(类型为 cl_platform_id)。第二次调用该API是，就可将platforms传入来获取对应数量的平台对象。在平台查找完成后，使用`clGetPlatformInfo()`API可以查询对应供应商所提供的平台，然后决定使用哪个平台进行运行OpenCL程序。本章中，`clGetPlatformIDs()`这个API需要在其他API之前调用，3.6节中可以从矢量相加的源码中进一步了解。

```c++
cl_int
clGetPlatformIDs(
  cl_uint num_entries,
  cl_platform_id *platforms,
  cl_uint *num_platforms)
```

当平台确定好之后，下一步就是要查询平台上可用的设备了。`clGetDeviceIDs()`API就是用来做这件事的，并且在使用流程上和`clGetPlatformIDs()`很类似。`clGetDeviceIDs()`多了平台对象和设备类型作为入参，不过也需要简单的三步就能创建device：第一，查询设备的数量；第二，分配对应数量的空间来存放设备对象；第三，选择期望使用的设备(确定设备对象)。`device_type`参数可以将设备限定为GPU(CL_DEVICE_TYPE_GPU)，限定为CPU(CL_DEVICE_TYPE_CPU)，或所有设备(CL_DEVICE_TYPE_ALL)，当然还有其他选项。这些参数都必须使用到`clGetDeviceIDs()`。相较于平台的查询API，`clGetDeviceInfo()`API可用来查询每个设备的名称、类型和供应商。

```c++
cl_int
clGetDeviceIDs(
  cl_platform_id platform,
  cl_device_type device_type,
  cl_uint num_entries,
  cl_device_id *devices,
  cl_uint *num_devices)
```

