#3.3 OpenCL执行模型

OpenCL执行模型允许我们建立一个拓扑系统来协调，主处理器和其他能够执行OpenCL kernel的设备。为了让kernel执行在设备上，还需要对OpenCL上下文进行设置，进而传递执行命令和数据到设备端。

##3.3.1 上下文

OpenCL中，上下文为了kernel的正确执行，保证合法的协调和管理内存。上下文是为了协调主机和设备端的交互，管理设备端可用的内存对象，并持续跟踪在设备上创建出来的程序对象和内核对象。上下文对象可以通过OpenCL API`clCreateContext()`进行创建。

```c++
cl_context
clCreateContext(
  const cl_context_properties *properties,
  cl_uint num_devices,
  const cl_device_id *devices,
  void (CL_CALL_BACK *pfn_notify)(
    const char *errinfo,
	const void *private_info,
	size_t cb,
	void *user_data),
  void *user_data,
  cl_int *errcode_ret)
```

`properties`参数用于限制上下文作用的范围。这个参数可能由特定的平台提供，其能够使能与图像互用性，或使能其他能力。通过限制给定平台的上下文，允许编程者使用多个平台创建的不同的上下文，并且能在一个平台中混用多个供应商提供的设备。另外，创建上下文时必须要使用设备对象，并且编程者可以设置一个用户回调函数，还可以额外传递一个错误码(需要在错误码对象的生命周期内)用于获取API运行的状态。

OpenCL提供了另一个API也能用来创建上下文，其能使用设备列表来创建上下文。通过`clCreateContextFromType()`可以使用所有的设备类型(CPU、GPU和ALL)创建上下文。创建上下文之后，可以通过使用`clGetContextInfo()`来查询上下文中设备的数量，以及具体的设备对象。OpenCL中可使用上下文查询指定平台对象和设备对象，通过以上的步骤即可创建上下文，这些步骤也可用于任意OpenCL程序。

##3.3.2 命令队列

执行模型是指，设备端执行的任务，是基于主机端发送的命令。命令的指定行为包括执行kernel，进行数据传递和执行同步。某些设备也能自发一些命令，这种设备以及方式，我们在后面的章节中再进行讨论。

命令队列作为一种通信机制，可以让host发请求到对应的device。当host需要device执行任务的时候，就需要一个命令队列。命令队列需要在每个设备上都进行创建，且命令队列要在上下文的基础上进行创建。host需要将一条命令提交到对应的命令队列中，因为命令队列不是以分发的形式，而是以指定的形式，所以如果平台上有多个设备时，就需要每个设备上创建一个命令队列。OpenCL中`clCreateCommandQueueWithProperties()`就是用来创建命令队列，且将命令队列与一个device进行关联。

```c++
cl_command_queue
clCreateCommandQueueWithProperties(
  cl_context context,
  cl_device_id device,
  cl_command_queue_properties peoperties,
  cl_int *errcode_ret)
```

`peoperties`参数是由一个位域值组成，其可以使能命令性能分析功能(CL_QUEUE_PROFILING_ENABLE)，以及/或允许命令乱序执行(CL_QUEUE_OUT_OF_DRDER_EXEC_MODE_ENABLE)。这两个功能将在第5章详细讨论。

对于顺序命令队列(默认创建)，会将命令顺序的推入对应的队列中。乱序命令队列允许OpenCL实现不按入队顺序执行对应的命令，这样的执行方式在某种情况下更为高效。如果使用乱序命令队列，其会根据用户指定的依赖关系，按正确的命令依赖顺序进行执行。

任何以`clEnqueue`开头的OpenCL API都能向命令队列提交一个命令，并且这些API都需要一个命令队列对象作为输入参数。例如，`clEnqueueReadBuffer()`将device上的数据传递到host，`clEnqueueNDRangeKernel()`申请一个kernel在对应device执行。如何调用这些API将在后续的章节中进行讨论。

除了向命令队列提交命令的API，OpenCL还包括执行栅栏操作API，这种操作可以用来同步命令队列。`clFlush()`和`clFinish()`这两个API都能对命令队列进行栅栏操作。其中，`clFinish()`的调用将会阻塞host上的执行线程，直到命令队列上的所有命令执行完毕；其功能就是和同步栅栏操作一样。`clFlush()`将会阻塞host上的执行线程，直到命令队列上的命令都从队列上移出。移出命令队列后的命令，就已经提交到device端，不过不一定完全执行完成。这两个API都需要一个命令队列作为参数。

```c++
cl_int clFlush(cl_command_queue command_queue);
cl_int clFinish(cl_command_queue command_queue);
```

##3.3.3 事件

##3.3.4 设备端入对

