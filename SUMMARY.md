# 目录

* [序言](content/Foreword/Foreword-chinese.md)
* [第1章 简介异构计算](content/chapter1/1.0-chinese.md)
	* [1.1 关于异构计算](content/chapter1/1.1-chinese.md)
	* [1.2 本书目的](content/chapter1/1.2-chinese.md)
	* [1.3 并行思想](content/chapter1/1.3-chinese.md)
	* [1.4 并发和并行编程模型](content/chapter1/1.4-chinese.md)
	* [1.5 线程和共享内存](content/chapter1/1.5-chinese.md)
	* [1.6 消息通讯机制](content/chapter1/1.6-chinese.md)
	* [1.7 并行性的粒度](content/chapter1/1.7-chinese.md)
	* [1.8 使用OpenCL进行异构计算](content/chapter1/1.8-chinese.md)
	* [1.9 本书结构](content/chapter1/1.9-chinese.md)
* [第2章 设备架构](content/chapter2/2.0-chinese.md)
	* [2.1 介绍](content/chapter2/2.1-chinese.md)
	* [2.2 硬件的权衡](content/chapter2/2.2-chinese.md)
	* [2.3 架构设计空间](content/chapter2/2.3-chinese.md)
	* [2.4 本章总结](content/chapter2/2.4-chinese.md)
* [第3章 介绍OpenCL](content/chapter3/3.0-chinese.md)
	* [3.1 简介OpenCL](content/chapter3/3.1-chinese.md)
	* [3.2 OpenCL平台模型](content/chapter3/3.2-chinese.md)
	* [3.3 OpenCL执行模型](content/chapter3/3.3-chinese.md)
	* [3.4 内核和OpenCL编程模型](content/chapter3/3.4-chinese.md)
	* [3.5 OpenCL内存模型](content/chapter3/3.5-chinese.md)
	* [3.6 OpenCL运行时(例子)](content/chapter3/3.6-chinese.md)
	* [3.7 OpenCL C++ Wapper向量加法](content/chapter3/3.7-chinese.md)
	* [3.8 CUDA编程者使用OpenCL的注意事项](content/chapter3/3.8-chinese.md)
* [第4章 实际OpenCL案例](content/chapter4/4.0-chinese.md)
	* [4.1 OpenCL实例](content/chapter4/4.1-chinese.md)
	* [4.2 直方图](content/chapter4/4.2-chinese.md)
	* [4.3 图像旋转](content/chapter4/4.3-chinese.md)
	* [4.4 图像卷积](content/chapter4/4.4-chinese.md)
	* [4.5 生产者-消费者](content/chapter4/4.5-chinese.md)
	* [4.6 基本功能函数]()
	* [4.7 本章总结]()
* [第5章 OpenCL运行时和并发模型]()
	* [5.1 命令和排队模型]()
	* [5.2 多命令队列]()
	* [5.3 内核执行域:工作项、工作组和NDRange]()
	* [5.4 原生和内置内核]()
	* [5.5 设备端排队]()
	* [5.6 本章总结]()
* [第6章 OpenCL主机端内存模型]()
	* [6.1 内存对象]()
	* [6.2 内存管理]()
	* [6.3 共享虚拟内存]()
	* [6.4 本章总结]()
* [第7章 OpenCL设备端内存模型]()
	* [7.1 同步和交互]()
	* [7.2 全局内存]()
	* [7.3 常量内存]()
	* [7.4 局部内存]()
	* [7.5 私有内存]()
	* [7.6 统一地址空间]()
	* [7.7 内存序]()
	* [7.8 本章总结]()
* [第8章 异构系统下解析OpenCL]()
	* [8.1 AMD FX-8350 CPU]()
	* [8.2 AMD RADEON R9 290X CPU]()
	* [8.3 OpenCL内存性能的考量]()
	* [8.4 本章总结]()
* [第9章 案例分析：图像聚类]()
	* [9.1 介绍图像聚类]()
	* [9.2 CPU上直方图的特性]()
	* [9.3 OpenCL实现]()
	* [9.4 性能分析]()
	* [9.5 本章总结]()
* [第10章 OpenCL的分析和调试]()
	* [10.1 设置本章的原因]()
	* [10.2 使用事件分析OpenCL代码]()
	* [10.3 AMD CodeXL]()
	* [10.4 如何使用AMD CodeXL]()
	* [10.5 使用CodeXL分析内核]()
	* [10.6 使用CodeXL调试OpenCL内核]()
	* [10.7 使用`printf`调试]()
	* [10.8 本章总结]()
* [第11章 高级语言映射到OpenCL2.0 —— 从编译器作者的角度]()
	* [11.1 简要介绍现状]()
	* [11.2 C++ AMP的简单介绍]()
	* [11.3 编译器的目标 —— OpenCL 2.0]()
	* [11.4 C++ AMP与OpenCL对比]()
	* [11.5 C++ AMP的编译流]()
	* [11.6 编译之后的C++ AMP代码]()
	* [11.7 为什么在OpenCL 2.0提出共享虚拟内存]()
	* [11.8 编译器怎样支持C++ AMP的线程块划分]()
	* [11.9 地址空间的推演]()
	* [11.10 优化数据转移]()
	* [11.11 完整例子:二项期权]()
	* [11.12 初步结果]()
	* [11.13 本章总结]()
* [第12章 WebCL：使用OpenCL加速Web应用]()
	* [12.1 介绍WebCL]()
	* [12.2 如何使用WebCL编程]()
	* [12.3 同步机制]()
	* [12.4 WebCL的交互性]()
	* [12.5 应用实例]()
	* [12.6 安全增强]()
	* [12.7 服务器端使用WebCL]()
	* [12.8 WebCL的状态和特性]()
* [第13章 其他高级语言中OpenCL的使用]()
	* [13.1 简介]()
	* [13.2 不仅只有C和C++]()
	* [13.3 Haskell中使用OpenCL]()
	* [13.4 本章总结]()
