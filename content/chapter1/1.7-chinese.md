#1.7 并行性的粒度

不论是在线程中使用共享内存，还在使用消息传递机制，我们都能调整线程的粒度。在研究并行计算时，粒度是线程中计算量与通讯量(比如，需要在线程间进行同步的变量)。

并行的粒度由算法的特点所决定，选择合适的并行粒度对于编程者来说很重要，合适的粒度能就能够在当前设备上获得最优的性能。有时对于粒度选择就像是在分块，然后决定哪些数据给予哪个任务。选择了合适的块大小可以就能在并行硬件上获得性能收益。如何选择并行程序的粒度，可以参考下面列出一些经验。

使用细粒度并行时，需要考虑如下几点：

- 计算量不要过大，这样每个线程都有足够的工作可做。
- 尽可能减少在数据同步上的开销，这样每个线程能够独立的完成自己的任务。
- 负载的划分也很重要，因为有大量的独立任务需要并行执行，设计良好的任务调度器都能灵活控制负载，并保证在多任务运行的同时，让线程上的达到均衡。

使用粗粒度并行时，需要考虑如下几点：

- 计算量肯定要高于细粒度并行时的计算量，因为不会像细粒度并行那样，有很多线程同时执行。
- 编程者使用粗粒度编程时，需要了解应用的整体结构，让粗粒度中的每个线程作为任务，服务于应用。

结合给出的建议，考虑一下自己的应用要选择哪种粒度的实现。其实，最合理的粒度取决于所要使用的算法和运行的硬件平台。大多数情况下，当同步和通讯的开销大于计算，那么将并行粒度加大，有利于控制同步和通讯所需的过高开销。细粒度并行能减少负载不均和访存延迟在性能上的开销(对于GPU来说更是如此，其为粒度之细可以切换线程时达到零开销，同时也能隐藏访存延迟)。

当一个算法需要对大量数据进行同一组操作时，就可将数据视为向量，执行同一操作时，多个数据作为输入，在经过向量操作后，输出多个数据。这种执行方式就是利用单指令多数据(SIMD)的方式对数据进行处理，可并行硬件可以利用这种执行方式，并行的对不同的数据数据进行处理。这种粒度的并行化与向量的大小有关，通过SIMD执行单元的多数据处理来获得应用性能上的提升。

寻找和尝试最好的计算粒度时，是否考虑过为什么不将统一程序中的所有副本拷贝到其他处理单元和节点上，如果能够这样，是不是就不用理会执行单元的执行顺序，并且能让程序高效的运行在一个有着多处理器的共享系统上呢？SIMD模型与单程序多数据(SPMD)模型很相似，SPMD模型和SIMD模型都不会对指令边界进行同步的限制，并且允许这些副本任务或kernel能够并发的执行。

##1.7.1 数据共享与同步

##1.7.2 共享虚拟内存

